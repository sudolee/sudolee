/* AT&T assembler */

1, .globl
 定义一个全局符号, 代码的任何地方都可以访问.

2, .balign arg1, arg2
 以当前地址开始,找到第一次出现的以第一个参数为整数倍的地址,并将其作为结束地址.
 在这个结束地址前面存储一个字节长度的数据,存储内容正是第二个参数.
 如果当前地址正好是第一个参数的倍数,则没有数据被写入到内存.

3, .word <arg>, [arg], ...
 预留一个或多个字的空间, 用来存放数据arg.
 类似的还有:
  - .byte 字节8 bits
  - .long 32 bits
  - .ascii 字符串
  - .asciz 字符串加'\0'

4, .equ <lable>, value
 在程序中用$lable使用value的值. 静态的, 值不能修改.

5, .type <lable>, function/object
 lable标签作为"函数(function)"或者"数据(object)"的开始.
 function/object前面可能要求有@/#前缀.

6, .fill length [, size, value]
 在data段, 预留length个size(默认是1byte)大小的缓冲区, 并用value(默认是0)初始化.
 e.g. 在buffer标签处预留1024个byte, 并初始化为0
  buffer:
   .fill 1024, 1, 0
  

7, .comm / .lcomm <lable>, length
 在bss段, 从内存标签lable开始预留length个bytes的缓冲区(不初始化).
 - .comm 可以用作.globl, 可以被外部访问.
 - .lcomm 不可用作.globl, 只能本地访问.

8, .extern func
 在汇编代码里声明一个外部函数. 链接时必须和用到的文件一起编译.
 p.s. 在c代码中调用汇编代码里的.globl函数时:
  extern void func(void);


/* inline assembly */
1, 扩展内嵌汇编的格式(external inline assembly format):
 __asm__("assembly code" : output locations : input operands : changned registers);

2, 全局变量: 可以直接引用

3, 寄存器: 需要用两个"%", e.g. "movl $1024, %%eax;"

4, 占位符: %<number>
 e.g. %0, %1, %2, %3...
 - 如果在一个代码块中使用了多个占位符, 则必须按%0, %1, %2...的顺序进行设置对应引用的输入输出值.
  e.g. func()中string设置%0, len设置%1.
 - 需要设置"约束符" (详见约束符表)

5, 使用内存位置
 设置好输入输出值的约束符即可.

6, 指定输入和输出:
 多个输入输出值用","(逗号)隔开.
+-------------------------------------------------------------+
|     约束符        |   描述                                  |
+-------------------------------------------------------------+
|    输入约束符                                               |
+-------------------------------------------------------------+
|    a              |   使用%eax, %ax, %al寄存器              |
|    b              |   使用%ebx, %bx, %bl寄存器              |
|    c              |   使用%ecx, %cx, %cl寄存器              |
|    d              |   使用%edx, %dx, %dl寄存器              |
|    S              |   使用%esi, %si寄存器                   |
|    D              |   使用%edi, %di寄存器                   |
|    r              |   使用任意通用寄存器                    |
|    q              |   使用%eax, %ebx, %ecx, %edx寄存器之一  |
|    A              |   对于64位值, 使用%eax和%edx寄存器      |
|    f              |   使用浮点寄存器                        |
|    t              |   使用第一个(顶部的)浮点寄存器          |
|    u              |   使用第二个浮点寄存器                  |
|    m              |   使用变量的内存位置                    |
|    o              |   使用偏移内存位置                      |
|    V              |   只使用直接内存位置                    |
|    i              |   使用立即整数值                        |
|    n              |   使用值已知的立即整数值                |
|    g              |   使用任何可用的寄存器或者内存位置      |
+-------------------------------------------------------------+
|   输出约束                                                  |
+-------------------------------------------------------------+
|    +              |   可读可写                              |
|    =              |   只写                                  |
|    %              |   如果需要操作数可以和下一个操作数切换  |
|    &              |   在内联函数完成前, 可以删除或者重新使用|
+-------------------------------------------------------------+
